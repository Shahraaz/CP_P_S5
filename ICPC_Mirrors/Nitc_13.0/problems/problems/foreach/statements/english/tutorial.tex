\begin{tutorial}{Foreach}

{
    \parindent=1cm
    \begin{tabular}{l@{\extracolsep{1cm}}l}
         Идея задачи: & Павел Кунявский\\
         Условие: & Павел Кунявский\\
         Проверяющая программа: & Павел Кунявский\\
         Тесты: & Павел Кунявский\\
     \end{tabular}
}

Если в массиве $b$ есть значения, которых не было в $a$, то ответа не существует.
Кроме того, так как первая же операция сделает какие-то два элемента одинаковыми, если $b$ не равен $a$ и все его элементы различны, то ответа не существует.

Во всех остальных случаях мы можем построить ответ из следующих базовых операций:
\begin{itemize}
 \item Заменить первое вхождение заданного значения на любой другой элемент массива;
 \item Заменить последний элемент на любой другой элемент массива.
\end{itemize}

Первая базовая операция может быть реализована как два цикла~--- сначала по ссылке до начального значения, потом без ссылка до конечного. Вторая операция может быть реализована аналогично, если в качестве значения первого цикла взять такое, которого нет в массиве.

Мы будем устанавливать элементы в правильное значение справа налево, пропустив последний элемент.
Чтобы установить очередной элемент, нужно все равные значения раньше заменить на что-нибудь другое, потом сохранить значение этого элемента в последний, а это сделать правильным.

Единственная проблема которая может возникнуть --- мы могли уже потерять все нужные значения. Чтобы такого не случилось, последний элемент никогда не должен быть уникальным. Для этого, если он становится уникальными, мы можем найти любое значение на необработанном префиксе, которое не уникально, или уже есть среди обработанных элементов, и заменить его на ещё одну копию значения последнего элемента.

После этого процесса, можно поставить последний элемент в нужное значение, и задача решена.

К сожалению, если несколько первых элементов массива вместе с последним уникальны, и не встречаются нигде больше, то на каком-то из шагов мы можем не найти куда скопировать значение последнего элемента.

Чтобы избежать этого, можно поменять конечный массив, заменив первый неуникальный элемент на значение первого элемента, и сначала преобразовать в такой массив.
Теперь, осталось поменять один элемент на значение, которое есть где-то ещё.
Так как мы выбирали первый такой элемент, ни одно из значение между первым и измененным элементов не равно ни первому, ни последнему, ни правильному значению изменённого.

Оставшаяся часть решается следующим образом. Пусть текущие значения первого, изменённого и последнего элемента это $[x, x, y]$, а целевые~--- $[x, z, y]$.
Тогда можно сделать следующую последовательность операций: $$[x, x, y] \rightarrow [y, x, y] \rightarrow [y, x, x] \rightarrow [y, y, x] \rightarrow [x, y, y] \rightarrow [x, z, y]$$
Заметим, что их можно делать даже если $z = y$. А $x$ не может быть равен  $y$ или $z$, так как первый элемент был уникален.

Решению требуется $O(n^2)$ циклов, что, кстати, является оптимальной асимптотикой на тесте вида $a = [0, 1, 0, 1, 0, 1, \dots]$, $b = [1, 0, 1, 0, 1, 0, \dots]$. Вероятно, есть много других решений.

\end{tutorial}
