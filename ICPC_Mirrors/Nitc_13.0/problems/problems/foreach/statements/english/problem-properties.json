{"scoring":null,"notes":"","legend":"Do you like really good programming languages?  Let's, for example, discuss PHP.\r\n\r\nPHP, like many other languages, supports arrays. For purposes of this problem, we only consider an array with consecutive integer indexes starting from 0. It would be denoted as $[a_0, a_1, \\dots, a_{n-1}]$.\r\n\r\nPHP, like many other languages, supports variables. All of them must start with \\t{\\$} symbol. We will have two in this problem: array \\t{\\$a}, and its element \\t{\\$x}.\r\n\r\nAlso, as many other languages, PHP supports loops over all elements of array. We consider only two of four possible forms of \\t{foreach} loop:\r\n\\begin{align*}\r\n\\text{non-reference form:\\hspace{3em}} & \\t{foreach (\\$a as~~\\$x) // code} \\\\\r\n\\text{reference form:\\hspace{3em}} & \\t{foreach (\\$a as~\\&\\$x) // code}\r\n\\end{align*}\r\n\r\nFormally, non-reference form goes through elements of the array one by one, and sets the value of \\t{\\$x} to the value of the corresponding element and then executes specified code. Reference form goes though elements of the array one by one and makes \\t{\\$x} a reference to the corresponding element and then executes code. So, in the first case, if one changes the value of \\t{\\$x}, the value of the array element wouldn't be changed, while in the second one it would.\r\n\r\nPHP supports a lot of other control-flow constructions. Two of them we are interested in are \\t{if} and \\t{break}. As in other languages, \\t{break} stops the loop immediately, and \\t{if} allows to execute code only if some condition holds.\r\n\r\nUnfortunately, unlike many other languages, PHP doesn't have variable scopes. So, even after a reference form \\t{foreach} loop, variable \\t{\\$x} still would be a reference to an element of the array it was set to last time. So, changing its value after the loop would still change the element of the array. On the other side, making \\t{\\$x} a reference to another element doesn't change the value of the previous element. Let's consider an example.\r\n\r\nOne has an array $[1, 2, 3]$ and executes the following code \r\n\r\n\\begin{center}\r\n\\t{foreach (\\$a as~\\&\\$x) if (\\$x == 2) break;} \\\\\r\n\\t{foreach (\\$a as~~\\$x) if (\\$x == 2) break;} \\\\\r\n\\end{center}\r\n\r\nAfter the first loop \\t{\\$x} is a reference to the middle element of the array. On the first step of the second loop, the array becomes $[1, 1, 3]$, because the value of \\t{\\$x} is changed to 1, and it is the reference to the middle element. On the second step, the value of \\t{\\$x} would be changed to a new value of the next element of the array, which turned out to be 1 again. It's still not equal to 2, so on the next step, the value of \\t{\\$x} changes to 3, and the resulting state of the array is $[1, 3, 3]$.\r\n\r\nAs you see, code can change arrays even having no explicit sets of variables.\r\n\r\nCan you create a program that changes one array to another using only lines of the form shown in the example above?","authorLogin":"pkunyavskiy","language":"english","timeLimit":2000,"output":"If it is not possible to change the state of array \\t{\\$a} from $s$ to $t$, output a single line containing a single integer $-1$. \r\n\r\nOtherwise, the first line of the output must contain an integer $k$~--- the number of lines in the program~($0 \\le k \\le 10\\,000$). You don't have to minimize this value.\r\n\r\nEach of the following $k$ lines should be either in the form\r\n\r\n\\begin{center} \r\n\\t{foreach (\\$a as~\\&\\$x) if (\\$x == <some integer value>) break;}\r\n\\end{center}\r\n\r\nor \r\n\r\n\\begin{center} \r\n\\t{foreach (\\$a as~~\\$x) if (\\$x == <some integer value>) break;}\r\n\\end{center}\r\n\r\nAll integers should be positive and should not exceed 100. No other variables or language constructions are allowed. You should follow the format as close as possible, including whitespaces (e.~g. there should be two spaces between \\t{as} and \\t{\\$x} in the non-reference form). Note that since there is no ``\\t{Presentation Error}'' outcome in the contest rules, if you fail to follow these requirements, you will get ``\\t{Wrong answer}'' outcome.\r\n\r\nYour code will be executed by formal rules described in the statement. It must convert array \\t{\\$a} from the initial state to the target state.","inputFile":"stdin","outputFile":"stdout","input":"The first line of the input contains one integer $n$~--- the length of the array \\t{\\$a}  ($1 \\le n \\le 50$). \r\nThe second line contains $n$ integers $s_i$~--- the initial state of the array ($1 \\le s_i \\le 100$). \r\nThe third line contains $n$ integers $t_i$~--- the target state of the array  ($1 \\le t_i \\le 100$).","authorName":"Pavel Kunyavskiy","sampleTests":[{"output":"2\r\nforeach ($a as &$x) if ($x == 2) break;\r\nforeach ($a as  $x) if ($x == 2) break;","input":"3\r\n1 2 3\r\n1 3 3\r\n","inputFile":"example.01","outputFile":"example.01.a"},{"output":"-1\r\n","input":"2\r\n1 2\r\n1 3\r\n","inputFile":"example.02","outputFile":"example.02.a"}],"name":"Foreach","interaction":null,"memoryLimit":536870912,"tutorial":"{\r\n    \\parindent=1cm\r\n    \\begin{tabular}{l@{\\extracolsep{1cm}}l}\r\n         Idea: & Pavel Kunyavskiy\\\\\r\n         Statement: & Pavel Kunyavskiy\\\\\r\n         Checker: & Pavel Kunyavskiy\\\\\r\n         Tests: & Pavel Kunyavskiy\\\\\r\n     \\end{tabular}\r\n}\r\n\r\nIf there are new values in b answer is -1.\r\nAlso, as the first change would make two elements the same, if all elements in b are different,\r\nand b is not equal to a, the answer is -1.\r\n\r\nOtherwise, we can construct an answer from to following base operations:\r\n\\begin{itemize}\r\n \\item set any value existing in array to the first element with the given value\r\n \\item set any value existing in array to the last element.\r\n\\end{itemize}\r\n\r\nThe first base operation can be implemented as two loops~--- first in reference form with an initial value,\r\nand second in the non-reference form with finish value.\r\nSecond can be implemented in the same way, with the first loop until value which is not in the array.\r\n\r\nWe will set elements to correct one-by-one, from right to left, skipping the last one.\r\nTo set each element, we need to change every same value before it to something else,\r\nthen move this value to the last element, and move correct value to this element.\r\n\r\nThe only problem can happen, if we already lost all elements of some value.\r\nTo avoid this, the last element should never be unique.\r\nIf it becomes unique, we can find any value on an unprocessed prefix,\r\nwhich is not unique, not needed in target prefix, or already exists in processed elements, and copy the value to it.\r\n\r\nAfter that process, we can fix the last element, and we are done.\r\n\r\nUnfortunately, if several first elements of target array and the last element are all distinct,\r\nand doesn't appear anywhere else in target array, it's possible that on one of the steps we can't\r\nfind a good element to save the value of the last one.\r\n\r\nTo fix it, let's modify the target array, by replacing the first non-unique element by the value of the first element,\r\nand first come to this array. Now we need to change one element, to value existing somewhere else.\r\nAlso, as we chose the first such element, no value between first and replaced element is equal to any of\r\nfirst, last or replace element target values.\r\n\r\nLast part can be solved as following. If current values of first, replaced and last are $[x, x, y]$ and target\r\nare $[x, z, y]$ following operation sequence is possible\r\n$$[x, x, y] \\rightarrow [y, x, y] \\rightarrow [y, x, x] \\rightarrow [y, y, x] \\rightarrow [x, y, y] \\rightarrow [x, z, y]$$.\r\nNote, they are correct even if $z = y$. And $x$ can't be equal to $y$ or $z$ as the first element was unique.\r\n\r\nThis solutions requires $O(n^2)$ loops, which is optimal on test $a = [0, 1, 0, 1, 0, 1, \\dots]$, $b = [1, 0, 1, 0, 1, 0, \\dots]$. Probably, a lot of other solutions exists.  \r\n\r\n{\r\n    \\parindent=1cm\r\n    \\begin{tabular}{l@{\\extracolsep{1cm}}l}\r\n         Идея задачи: & Павел Кунявский\\\\\r\n         Условие: & Павел Кунявский\\\\\r\n         Проверяющая программа: & Павел Кунявский\\\\\r\n         Тесты: & Павел Кунявский\\\\\r\n     \\end{tabular}\r\n}\r\n\r\nЕсли в массиве $b$ есть значения, которых не было в $a$, то ответа не существует. \r\nКроме того, так как первая же операция сделает какие-то два элемента одинаковыми, если $b$ не равен $a$ и все его элементы различны, то ответа не существует.\r\n\r\nВо всех остальных случаях мы можем построить ответ из следующих базовых операций:\r\n\\begin{itemize}\r\n \\item Заменить первое вхождение заданного значения на любой другой элемент массива;\r\n \\item Заменить последний элемент на любой другой элемент массива.\r\n\\end{itemize}\r\n\r\nПервая базовая операция может быть реализована как два цикла~--- сначала по ссылке до начального значения, потом без ссылка до конечного. Вторая операция может быть реализована аналогично, если в качестве значения первого цикла взять такое, которого нет в массиве. \r\n\r\nМы будем устанавливать элементы в правильное значение справа налево, пропустив последний элемент.\r\nЧтобы установить очередной элемент, нужно все равные значения раньше заменить на что-нибудь другое, потом сохранить значение этого элемента в последний, а это сделать правильным. \r\n\r\nЕдинственная проблема которая может возникнуть --- мы могли уже потерять все нужные значения. Чтобы такого не случилось, последний элемент никогда не должен быть уникальным. Для этого, если он становится уникальными, мы можем найти любое значение на необработанном префиксе, которое не уникально, или уже есть среди обработанных элементов, и заменить его на ещё одну копию значения последнего элемента. \r\n\r\nПосле этого процесса, можно поставить последний элемент в нужное значение, и задача решена. \r\n\r\nК сожалению, если несколько первых элементов массива вместе с последним уникальны, и не встречаются нигде больше, то на каком-то из шагов мы можем не найти куда скопировать значение последнего элемента. \r\n\r\nЧтобы избежать этого, можно поменять конечный массив, заменив первый неуникальный элемент на значение первого элемента, и сначала преобразовать в такой массив. \r\nТеперь, осталось поменять один элемент на значение, которое есть где-то ещё. \r\nТак как мы выбирали первый такой элемент, ни одно из значение между первым и измененным элементов не равно ни первому, ни последнему, ни правильному значению изменённого. \r\n\r\nОставшаяся часть решается следующим образом. Пусть текущие значения первого, изменённого и последнего элемента это $[x, x, y]$, а целевые~--- $[x, z, y]$.  \r\nТогда можно сделать следующую последовательность операций: $$[x, x, y] \\rightarrow [y, x, y] \\rightarrow [y, x, x] \\rightarrow [y, y, x] \\rightarrow [x, y, y] \\rightarrow [x, z, y]$$.\r\nЗаметим, что их можно делать даже если $z = y$. А $x$ не может быть равен  $y$ или $z$, так как первый элемент был уникален.\r\n\r\nРешению требуется $O(n^2)$ циклов, что, кстати, является оптимальной асимптотикой на тесте вида $a = [0, 1, 0, 1, 0, 1, \\dots]$, $b = [1, 0, 1, 0, 1, 0, \\dots]$. Вероятно, есть много других решений."}