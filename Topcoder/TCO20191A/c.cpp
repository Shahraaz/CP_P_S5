//Optimise
#include <bits/stdc++.h>
using namespace std;

#define Debug
#ifdef Debug
#define db(...) ZZ(#__VA_ARGS__, __VA_ARGS__);
#define pc(...) PC(#__VA_ARGS__, __VA_ARGS__);
template <typename T, typename U>
ostream &operator<<(ostream &out, const pair<T, U> &p)
{
	out << '[' << p.first << ", " << p.second << ']';
	return out;
}
template <typename Arg>
void PC(const char *name, Arg &&arg)
{
	std::cerr << name << " { ";
	for (const auto &v : arg)
		cerr << v << ' ';
	cerr << " }\n";
}
template <typename Arg1>
void ZZ(const char *name, Arg1 &&arg1)
{
	std::cerr << name << " = " << arg1 << endl;
}
template <typename Arg1, typename... Args>
void ZZ(const char *names, Arg1 &&arg1, Args &&... args)
{
	const char *comma = strchr(names + 1, ',');
	std::cerr.write(names, comma - names) << " = " << arg1;
	ZZ(comma, args...);
}
#else
#define db(...)
#define pc(...)
#endif

using ll = long long;
#define f first
#define s second
#define pb push_back
const long long mod = 1000000007;

const int nax = 2e5 + 10;

class EllysTicketPrices
{
public:
	double getPrice(int N, vector<int> C, int target)
	{
		using ld = long double;
		auto correct = [](int x, int base) -> ld {
			return roundl(x);
		};
		auto getCost = [&](ld curr) -> ld {
			// cout << curr << ' ';
			curr = correct(curr);
			ld ret = curr;
			for (size_t i = 1; i < N; i++)
			{
				curr = correct((100 + C[i - 1]) * curr / 100);
				// cout << curr << ' ';
				ret += curr;
			}
			// cout << '\n';
			return correct(ret / N);
		};
		cerr << fixed << setprecision(5);
		// db(getCost(200));
		// return 0;
		ld low, high;
		low = 0, high = mod;
		while (high - low > 100)
		{
			auto mid = (low + high) / 2;
			// db(low, high, mid);
			// mid = correct(mid);
			// db(mid);
			if (getCost(mid) < target)
				low = mid;
			else
				high = mid;
		}
		db(low, high);
		low -= 100;
		high += 100;
		low *= 100;
		high *= 100;
		// db(target);
		// db(getCost(200));
		// db(getCost(184.01));
		// db(getCost(874.77));
		// db(getCost(476.28));
		db(getCost(303194.87), target);
		db(getCost(2971.23), target);
		for (int i = low; i <= high; i++)
			if (getCost(i / ld(100)) == target)
				return i / ld(100);
		return 0;
	}
};

#ifndef LOCAL
//<%:testing-code%>
#endif

#ifdef LOCAL
// int main()
// {
// 	return 0;
// }
// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, int p0, vector<int> p1, int p2, bool hasAnswer, double p3)
{
	cout << "Test " << testNum << ": [" << p0 << ","
		 << "{";
	for (int i = 0; int(p1.size()) > i; ++i)
	{
		if (i > 0)
		{
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}"
		 << "," << p2;
	cout << "]" << endl;
	EllysTicketPrices *obj;
	double answer;
	obj = new EllysTicketPrices();
	clock_t startTime = clock();
	answer = obj->getPrice(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer)
	{
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer)
	{
		res = fabs(p3 - answer) <= 1e-9 * max(1.0, fabs(p3));
	}
	if (!res)
	{
		cout << "DOESN'T MATCH!!!!" << endl;
	}
	else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
	{
		cout << "FAIL the timeout" << endl;
		res = false;
	}
	else if (hasAnswer)
	{
		cout << "Match :-)" << endl;
	}
	else
	{
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main()
{
	bool all_right;
	all_right = true;

	int p0;
	vector<int> p1;
	int p2;
	double p3;

	// {
	// 	// ----- test 0 -----
	// 	p0 = 5;
	// 	int t1[] = {-10, 15, 5, -20};
	// 	p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	// 	p2 = 180;
	// 	p3 = 184.01;
	// 	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// 	// ------------------
	// }

	// {
	// 	// ----- test 1 -----
	// 	p0 = 11;
	// 	int t1[] = {5, 16, 17, -3, -10, 20, 20, 14, 2, 0};
	// 	p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	// 	p2 = 1337;
	// 	p3 = 874.77;
	// 	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// 	// ------------------
	// }

	// {
	// 	// ----- test 2 -----
	// 	p0 = 2;
	// 	int t1[] = {0};
	// 	p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	// 	p2 = 42;
	// 	p3 = 42.0;
	// 	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// 	// ------------------
	// }

	// {
	// 	// ----- test 3 -----
	// 	p0 = 20;
	// 	int t1[] = {30, -26, 87, 47, -39, 25, -67, 62, -38, 68, -84, 5, 28, -20, 50, -61, 10, 63, -71};
	// 	p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	// 	p2 = 392;
	// 	p3 = 476.28;
	// 	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// 	// ------------------
	// }

	// {
	// 	// ----- test 4 -----
	// 	p0 = 50;
	// 	int t1[] = {-60, 61, 17, 86, 56, 27, 9, 41, -27, -36, 57, -16, 1, 50, -55, -36, 14, 13, -93, 14, 18, 25, 62, -18, 40, 79, 56, 19, 10, -55, -43, 45, -43, -84, 61, -64, 41, -55, 38, 18, 36, -43, 79, 33, 87, 19, -47, 38, -56};
	// 	p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	// 	p2 = 8887;
	// 	p3 = 9451.93;
	// 	all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
	// 	// ------------------
	// }

	{
		p0 = 50;
		int t1[] = {-96, -58, -8, -22, -3, -5, 1, -9, 8, -6, 4, 13, 5, -18, 5, 3, 2, 13, 10, 6, 8, -9, -7, 14, -18, -22, 14, 7, 5, 10, 11, 13, -33, 2, -4, -5, 10, -2, -11, -6, 13, 13, -18, 9, 12, -5, 12, 10, -8};
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		p2 = 10000;
		p3 = 303194.87;
		all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
	}
	{
		p0 = 50;
		int t1[] = {0, 0, -10, -10, 5, -10, -20, -10, -5, 0, 0, 2, 3, 10, -2, 5, 6, 7, 10, 12, 15, 17, 20, 20, 7, 3, 2, -50, 60, 99, -80, 99, 30, 30, 30, 20, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -10, -70};
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		p2 = 5042;
		p3 = 2971.23;
		all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
	}

	if (all_right)
	{
		cout << "You're a stud (at least on the example cases)!" << endl;
	}
	else
	{
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
#endif

//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!